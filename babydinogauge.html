

<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<link rel="apple-touch-icon" type="image/png" href="https://static.codepen.io/assets/favicon/apple-touch-icon-5ae1a0698dcc2402e9712f7d01ed509a57814f994c660df9f7a952f3060705ee.png" />
<meta name="apple-mobile-web-app-title" content="CodePen">
<link rel="shortcut icon" type="image/x-icon" href="https://static.codepen.io/assets/favicon/favicon-aec34940fbc1a6e787974dcd360f2c6b63348d4b1f4e06c77743096d55480f33.ico" />
<link rel="mask-icon" type="" href="https://static.codepen.io/assets/favicon/logo-pin-8f3771b1072e3c38bd662872f6b673a722f4b3ca2421637d5596661b4e2132cc.svg" color="#111" />
<meta name="robots" content="noindex">
<title>CodePen - Lighthouse - exploding gauge</title>
<style>
.lh-vars {
  --palette-0: #1de9b6;
  --palette-1: #7c4dff;
  --palette-2: #ffb200;
  --palette-3: #00affe;
  --palette-4: #ff4181;
  	/* Palette using Material Design Colors
     * https://www.materialui.co/colors */
  --color-amber-50: #FFF8E1;
  --color-blue-200: #90CAF9;
  --color-blue-900: #0D47A1;
  --color-blue-A700: #2962FF;
  --color-cyan-500: #00BCD4;
  --color-gray-100: #F5F5F5;
  --color-gray-200: #E0E0E0;
  --color-gray-400: #BDBDBD;
  --color-gray-50: #FAFAFA;
  --color-gray-500: #9E9E9E;
  --color-gray-600: #757575;
  --color-gray-700: #616161;
  --color-gray-800: #424242;
  --color-gray-900: #212121;
  --color-gray: #000000;
  --color-green-700: #018642;
  --color-green: #0CCE6B;
  --color-orange-700: #D04900;
  --color-orange: #FFA400;
  --color-red-700: #EB0F00;
  --color-red: #FF4E42;
  --color-teal-600: #00897B;
  --color-white: #FFFFFF;
  --color-average-secondary: var(--color-orange-700);
  --color-average: var(--color-orange);
  --color-fail-secondary: var(--color-red-700);
  --color-fail: var(--color-red);
  --color-informative: var(--color-blue-900);
  --color-pass-secondary: var(--color-green-700);
  --color-pass: var(--color-green);
  --color-hover: var(--color-gray-50);
  --report-font-family-monospace: 'Roboto Mono', 'Menlo', 'dejavu sans mono', 'Consolas', 'Lucida Console', monospace;
}

circle {
  stroke: currentcolor;
  r: var(--radius);
}

text {
  font-size: calc(var(--radius) * 0.2);
}

.lh-gauge {
  margin: 0 auto;
  width: 300px;
  stroke-width: var(--stroke-width);
  stroke-linecap: round;
}
.lh-gauge--faded {
  opacity: 0.1;
}
.lh-gauge__wrapper {
  font-family: var(--report-font-family-monospace);
  text-align: center;
  text-decoration: none;
  transition: .3s;
}
.lh-gauge__wrapper--pass {
  color: var(--color-pass);
}
.lh-gauge__wrapper--average {
  color: var(--color-average);
}
.lh-gauge__wrapper--fail {
  color: var(--color-fail);
}
.lh-gauge__wrapper.state--expanded {
  color: var(--color-gray-600);
}
.lh-gauge__wrapper.state--highlight {
  color: var(--color-highlight);
}
.lh-gauge__svg-wrapper {
  display: flex;
  flex-direction: column-reverse;
}
.lh-gauge__label {
  color: #000;
  font-weight: 400;
}
.lh-gauge__cutout {
  opacity: .999;
  transition: opacity .3s;
}
.state--highlight .lh-gauge__cutout {
  opacity: 0;
}
.lh-gauge__outer {
  mask: url(#lh-gauge__mask);
}
.lh-gauge__inner {
  color: inherit;
}
.lh-gauge__base {
  fill: currentcolor;
}
.lh-gauge__arc {
  fill: none;
  transition: opacity .3s;
}
.lh-gauge__arc--metric {
  color: var(--metric-color);
  stroke-dashoffset: var(--metric-offset);
}
.lh-gauge__arc--metric:not(.lh-gauge--faded) {
  opacity: 0;
  stroke-dasharray: 0 calc(var(--circle-meas) * var(--radius));
  transition: 0s .005s;
}
.state--expanded .lh-gauge__arc--metric:not(.lh-gauge--faded) {
  opacity: .999;
  stroke-dasharray: var(--metric-array);
  transition: 0.3s calc(.005s + var(--i)*.05s);
}
.state--expanded .lh-gauge__inner .lh-gauge__arc {
  opacity: 0;
}
.lh-gauge__percentage {
  text-anchor: middle;
  dominant-baseline: middle;
  fill: currentcolor;
  opacity: .999;
  font-size: calc(var(--radius)*.625px);
  transition: opacity .3s ease-in;
}
.state--highlight .lh-gauge__percentage {
  opacity: 0;
}

.cover {
  fill: none;
  opacity: .001;
  pointer-events: none;
}
.state--expanded .cover {
  pointer-events: auto;
}

.metric {
  transform: scale(var(--scale-initial));
  opacity: 0;
  transition: transform .1s .2s ease-out,  opacity .3s ease-out;
  pointer-events: none;
}
.metric text {
  pointer-events: none;
}
.metric__value {
  fill: currentcolor;
  opacity: 0;
  transition: opacity 0.2s;
}
.state--expanded .metric {
  transform: scale(1);
  opacity: .999;
  transition: transform .3s ease-out,  opacity .3s ease-in,  stroke-width .1s ease-out;
  transition-delay: calc(var(--i)*.05s);
  pointer-events: auto;
}
.state--highlight .metric {
  opacity: .3;
}
.state--highlight .metric--highlight {
  opacity: .999;
  stroke-width: calc(1.5*var(--stroke-width));
}
.state--highlight .metric--highlight .metric__value {
  opacity: 0.999;
}
</style>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prefixfree/1.0.7/prefixfree.min.js"></script>
</head>
<body translate="no">
<body class='lh-root lh-vars'>
<div hidden>
<template id='tmpl-lh-perf-gauge'>
<a href='#' class='lh-gauge__wrapper state--expanded'>
<div class='lh-gauge__svg-wrapper'>

<h2 class='lh-gauge__label'></h2>
<svg class='lh-gauge'>
<mask id='lh-gauge__mask' color='#000'></mask>

<g class='lh-gauge__inner'>

<circle class='lh-gauge__base lh-gauge--faded' />
<circle class='lh-gauge__arc' />

<text class='lh-gauge__percentage'></text>
</g>
<g class='lh-gauge__outer'>
<circle class='cover' />
</g>
</svg>
</div>
</a>
</template>
</div>
<div id='performance'></div>
</body>
<script id="rendered-js">
const groupDefinitions = { "metrics": { "title": "Metrics" } };
const category = {
  "title": "Performance",
  "auditRefs": [
  {
    "id": "first-contentful-paint",
    "weight": 3,
    "group": "metrics",
    "result": {
      "id": "first-contentful-paint",
      "title": "First Contentful Paint",
      "description": "First Contentful Paint marks the time at which the first text or image is painted. [Learn more](https://web.dev/first-contentful-paint).",
      "score": 0.51,
      "scoreDisplayMode": "numeric",
      "numericValue": 3969.135,
      "displayValue": "4.0 s" } },

  {
    "id": "first-meaningful-paint",
    "weight": 1,
    "group": "metrics",
    "result": {
      "id": "first-meaningful-paint",
      "title": "First Meaningful Paint",
      "description": "First Meaningful Paint measures when the primary content of a page is visible. [Learn more](https://web.dev/first-meaningful-paint).",
      "score": 0.51,
      "scoreDisplayMode": "numeric",
      "numericValue": 3969.136,
      "displayValue": "4.0 s" } },


  {
    "id": "speed-index",
    "weight": 4,
    "group": "metrics",
    "result": {
      "id": "speed-index",
      "title": "Speed Index",
      "description": "Speed Index shows how quickly the contents of a page are visibly populated. [Learn more](https://web.dev/speed-index).",
      "score": 0.74,
      "scoreDisplayMode": "numeric",
      "numericValue": 4417,
      "displayValue": "4.4 s" } },

  {
    "id": "interactive",
    "weight": 5,
    "group": "metrics",
    "result": {
      "id": "interactive",
      "title": "Time to Interactive",
      "description": "Time to interactive is the amount of time it takes for the page to become fully interactive. [Learn more](https://web.dev/interactive).",
      "score": 0.78,
      "scoreDisplayMode": "numeric",
      "numericValue": 4927.278,
      "displayValue": "4.9 s" } },


  {
    "id": "first-cpu-idle",
    "weight": 2,
    "group": "metrics",
    "result": {
      "id": "first-cpu-idle",
      "title": "First CPU Idle",
      "description": "First CPU Idle marks the first time at which the page's main thread is quiet enough to handle input.  [Learn more](https://web.dev/first-cpu-idle).",
      "score": 0.72,
      "scoreDisplayMode": "numeric",
      "numericValue": 4927.278,
      "displayValue": "4.9 s" } },


  {
    "id": "max-potential-fid",
    "weight": 0,
    "group": "metrics",
    "result": {
      "id": "max-potential-fid",
      "title": "Max Potential First Input Delay",
      "description": "The maximum potential First Input Delay that your users could experience is the duration, in milliseconds, of the longest task. [Learn more](https://web.dev/lighthouse-max-potential-fid).",
      "score": 0.92,
      "scoreDisplayMode": "numeric",
      "numericValue": 122.537,
      "displayValue": "120 ms" } }],



  "id": "performance",
  "score": 0.69 };


const RATINGS = {
  PASS: { label: 'pass', minScore: 0.9 },
  AVERAGE: { label: 'average', minScore: 0.5 },
  FAIL: { label: 'fail' } };


function calculateRating(score) {
  switch (true) {
    case score >= RATINGS.PASS.minScore:
      return RATINGS.PASS.label;
    case score >= RATINGS.AVERAGE.minScore:
      return RATINGS.AVERAGE.label;
    default:
      RATINGS.FAIL.label;}

};

/**
    * @param {HTMLAnchorElement} wrapper
    * @param {LH.ReportResult.Category} category
    */
function _setPerfGauge(wrapper, category) {
  const sizeSVG = 128;
  const offsetSVG = -.5 * sizeSVG;
  const radiusInner = .25 * sizeSVG;
  const strokeWidth = sizeSVG / 32;
  const strokeGap = .5 * strokeWidth;
  const radiusOuter = radiusInner + strokeGap + strokeWidth;

  const SVG = wrapper.querySelector('.lh-gauge');
  const NS_URI = 'http://www.w3.org/2000/svg';

  SVG.setAttribute('viewBox', [offsetSVG, offsetSVG, sizeSVG, sizeSVG].join(' '));
  SVG.style.setProperty('--stroke-width', strokeWidth);
  SVG.style.setProperty('--circle-meas', 2 * Math.PI.toFixed(4));

  // build the mask
  const mask = wrapper.querySelector('#lh-gauge__mask');
  const maskVisible = document.createElementNS(NS_URI, 'path');
  const maskHidden = document.createElementNS(NS_URI, 'circle');

  // a path is the most compact way to cover the SVG area with a rectangle
  maskVisible.setAttribute('d', `M${offsetSVG}${offsetSVG}H${-offsetSVG}V${-offsetSVG}H${offsetSVG}`);
  // SVG masks are luninance masks => white = fully opaque, black = transparent
  maskVisible.setAttribute('fill', `#fff`);
  // default fill is black, no need to set it exlicitly on circle
  // any strok applied doesn't matter
  maskHidden.setAttribute('r', radiusInner + .5 * strokeWidth);
  maskHidden.classList.add('lh-gauge__cutout');

  mask.appendChild(maskVisible);
  mask.appendChild(maskHidden);

  const groupOuter = wrapper.querySelector('.lh-gauge__outer');
  const groupInner = wrapper.querySelector('.lh-gauge__inner');
  const cover = groupOuter.querySelector('.cover');
  const gaugeArc = groupInner.querySelector('.lh-gauge__arc');
  const gaugePerc = groupInner.querySelector('.lh-gauge__percentage');

  const circumferenceInner = 2 * Math.PI * radiusInner;
  // arc length we need to subtract
  // for very small strokeWidth:radius ratios this is ≈ strokeWidth
  // angle = acute angle of isosceles △ with 2 edges equal to radius & 3rd equal to strokeWidth
  // angle formula given by law of cosines
  const endDiffInner = Math.acos(1 - .5 * Math.pow(.5 * strokeWidth / radiusInner, 2)) * radiusInner;

  const circumferenceOuter = 2 * Math.PI * radiusOuter;
  const endDiffOuter = Math.acos(1 - .5 * Math.pow(.5 * strokeWidth / radiusOuter, 2)) * radiusOuter;

  const percent = Number(category.score);
  const gaugeArcLength = Math.max(0, +(percent * circumferenceInner - 2 * endDiffInner).toFixed(4));

  groupOuter.style.setProperty('--scale-initial', radiusInner / radiusOuter);
  groupOuter.style.setProperty('--radius', `${radiusOuter}px`);
  cover.style.setProperty('--radius', `${.5 * (radiusInner + radiusOuter)}px`);
  cover.setAttribute('stroke-width', strokeGap);
  SVG.style.setProperty('--radius', `${radiusInner}px`);

  gaugeArc.setAttribute('stroke-dasharray', `${gaugeArcLength} ${(circumferenceInner - gaugeArcLength).toFixed(4)}`);
  gaugeArc.setAttribute('stroke-dashoffset', .25 * circumferenceInner - endDiffInner);

  gaugePerc.textContent = Math.round(percent * 100);

  const radiusTextOuter = radiusOuter + strokeWidth;
  const radiusTextInner = radiusOuter - strokeWidth;

  const metrics = category.auditRefs.filter(r => r.group === 'metrics' && r.weight);
  const totalWeight = metrics.reduce((sum, each) => sum += each.weight, 0);
  let offsetAdder = .25 * circumferenceOuter - endDiffOuter - .5 * strokeGap;
  let angleAdder = -.5 * Math.PI;

  const aliases = {
    "first-contentful-paint": 'FCP',
    "first-meaningful-paint": 'FMP',
    "speed-index": 'SI',
    "interactive": 'TTI',
    "first-cpu-idle": 'FCPUI' };


  metrics.forEach((metric, i) => {
    const metricGroup = document.createElementNS(NS_URI, 'g');
    const metricArcMax = document.createElementNS(NS_URI, 'circle');
    const metricArc = document.createElementNS(NS_URI, 'circle');
    const metricLabel = document.createElementNS(NS_URI, 'text');
    const metricValue = document.createElementNS(NS_URI, 'text');

    const alias = aliases[metric.id];

    metricGroup.classList.add('metric', `metric--${alias}`);
    metricArcMax.classList.add('lh-gauge__arc', 'lh-gauge__arc--metric', 'lh-gauge--faded');
    metricArc.classList.add('lh-gauge__arc', 'lh-gauge__arc--metric');

    const weightingPct = metric.weight / totalWeight;
    const metricLengthMax = Math.max(0, +(weightingPct * circumferenceOuter - 2 * endDiffOuter - strokeGap).toFixed(4));
    const metricPercent = metric.result.score * weightingPct;
    const metricLength = Math.max(0, +(metricPercent * circumferenceOuter - 2 * endDiffOuter - strokeGap).toFixed(4));
    const metricOffset = weightingPct * circumferenceOuter;

    metricGroup.style.setProperty('--metric-color', `var(--palette-${i})`);
    metricGroup.style.setProperty('--metric-offset', `${offsetAdder}`);
    metricGroup.style.setProperty('--i', i);

    metricArcMax.setAttribute('stroke-dasharray', `${metricLengthMax} ${circumferenceOuter - metricLengthMax}`);
    metricArc.style.setProperty('--metric-array', `${metricLength} ${circumferenceOuter - metricLength}`);

    metricLabel.classList.add('metric__label');
    metricValue.classList.add('metric__value');
    metricLabel.textContent = alias;
    metricValue.textContent = `+${Math.round(metricPercent * 100)}`;

    const midAngle = angleAdder + weightingPct * Math.PI;
    const cos = Math.cos(midAngle);
    const sin = Math.sin(midAngle);

    // only set non-default alignments
    switch (true) {
      case cos > 0:
        metricValue.setAttribute('text-anchor', 'end');
        break;
      case cos < 0:
        metricLabel.setAttribute('text-anchor', 'end');
        break;
      case cos === 0:
        metricLabel.setAttribute('text-anchor', 'middle');
        metricValue.setAttribute('text-anchor', 'middle');
        break;}


    switch (true) {
      case sin > 0:
        metricLabel.setAttribute('dominant-baseline', 'hanging');
        break;
      case sin < 0:
        metricValue.setAttribute('dominant-baseline', 'hanging');
        break;
      case sin === 0:
        metricLabel.setAttribute('dominant-baseline', 'middle');
        metricValue.setAttribute('dominant-baseline', 'middle');
        break;}


    metricLabel.setAttribute('x', (radiusTextOuter * cos).toFixed(2));
    metricLabel.setAttribute('y', (radiusTextOuter * sin).toFixed(2));
    metricValue.setAttribute('x', (radiusTextInner * cos).toFixed(2));
    metricValue.setAttribute('y', (radiusTextInner * sin).toFixed(2));

    metricGroup.appendChild(metricArcMax);
    metricGroup.appendChild(metricArc);
    metricGroup.appendChild(metricLabel);
    metricGroup.appendChild(metricValue);
    groupOuter.appendChild(metricGroup);

    offsetAdder -= metricOffset;
    angleAdder += weightingPct * 2 * Math.PI;
  });

  // addEventListener('mouseover', e => {
  //   if (e.target === SVG &&
  //   wrapper.classList.contains('state--expanded')) {
  //     wrapper.classList.remove('state--expanded');

  //     if (wrapper.classList.contains('state--highlight')) {
  //       wrapper.classList.remove('state--highlight');
  //       wrapper.querySelector('.metric--highlight').classList.remove('metric--highlight');
  //     }

  //     return;
  //   }

  //   const parent = e.target.parentNode;

  //   if (parent && parent === groupInner) {
  //     if (!wrapper.classList.contains('state--expanded'))
  //     wrapper.classList.add('state--expanded');else
  //     if (wrapper.classList.contains('state--highlight')) {
  //       wrapper.classList.remove('state--highlight');
  //       wrapper.querySelector('.metric--highlight').classList.remove('metric--highlight');
  //     }
  //     return;
  //   }

  //   if (parent && parent.classList && parent.classList.contains('metric')) {
  //     wrapper.style.setProperty('--color-highlight', `var(--palette-${parent.style.getPropertyValue('--i')})`);

  //     if (!wrapper.classList.contains('state--highlight')) {
  //       wrapper.classList.add('state--highlight');
  //       parent.classList.add('metric--highlight');
  //     } else
  //     {
  //       const highlighted = wrapper.querySelector('.metric--highlight');

  //       if (parent !== highlighted) {
  //         highlighted.classList.remove('metric--highlight');
  //         parent.classList.add('metric--highlight');
  //       }
  //     }
  //   }
  // }, false);
};

/**
   	* @param {LH.ReportResult.Category} category
   	* @param {Record<string, LH.Result.ReportGroup>} groupDefinitions
   	* @return {DocumentFragment}
   	*/
function renderScoreGauge(category, groupDefinitions) {// eslint-disable-line no-unused-vars
  const tmpl = document.querySelector('#tmpl-lh-perf-gauge');
  const tmplElem = document.importNode(tmpl.content, true);

  const wrapper = tmplElem.querySelector('.lh-gauge__wrapper');

  wrapper.href = `#${category.id}`;
  wrapper.classList.add(`lh-gauge__wrapper--${calculateRating(category.score)}`);

  _setPerfGauge(wrapper, category);

  tmplElem.querySelector('.lh-gauge__label').textContent = category.title;

  return tmplElem;
}

document.querySelector('#performance').append(renderScoreGauge(category, groupDefinitions));
    </script>
</body>
</html>
